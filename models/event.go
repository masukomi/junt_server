package models

import (
	"errors"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"strconv"
	"time"
)

// ┌──────────────────────────────────────────┐
// │Event                                     │
// │-------------------------------------     │
// │id:          int                          │
// │job_id    :  int                          │
// │created_at:  date_time                    │
// │people_ids:  array of ints (optional)     │
// │note:        string (optional - markdown) │
// │                                          │
// │belongs_to:  job                          │
// │has_and_belongs_to_many: people           │
// └──────────────────────────────────────────┘

type Event struct {
	Id        int64     `json:"id" gorm:"PRIMARY_KEY";"AUTO_INCREMENT" ` // generated by DB
	CreatedAt time.Time `json:"created_at"`                              // generated if not supplied
	UpdatedAt time.Time `json:"updated_at"`                              // generated if not supplied

	Note      string `sql:"type:text;" json:"note"` // markdown
	JobId     int64  `json:"job_id"`
	Job       Job    `gorm:"foreignkey:JobId" json:"-"`
	EventType string `json:"event_type" gorm:"-"`
}

func (e Event) GetJob() Job {
	return e.Job
}

/// boilerplate for IEvent
func (e Event) ExtractJob(db *gorm.DB) MaybeJob { // gets jobs via JobId
	job := Job{}
	if db.Preload("People").First(&job, e.JobId).Error != nil {
		return JustJob(job)
	}
	return ErrorJob(errors.New("invalid or no job id"))
}

func (e Event) GetJobId() int64 { // gets the ids from JobIds
	return e.Job.Id
}

func (e Event) SetJob(job Job) {
	e.Job = job
}
func (e Event) SetJobId(jobId int64) {
	e.JobId = jobId
}

func (e Event) CreationDate() time.Time {
	return e.CreatedAt
}

func (e Event) ConvertIdToJob(db *gorm.DB) error {
	job := Job{}
	if err := db.Preload("People").First(&job, e.JobId).Error; err != nil {
		e.SetJob(job)
		return nil
	} else {
		return err
	}
}

/// END IEvent boilerplate

func (e Event) HolisticDeletion(db *gorm.DB) (bool, error) {

	transaction := db.Begin()
	if err := db.Delete(&e).Error; err != nil {
		transaction.Commit()
		return true, nil
	} else {
		transaction.Rollback()
		return false, err
	}

}

func (e *Event) UpdateEventFromJson(data map[string]interface{}, db *gorm.DB) error {

	for key, value := range data {
		switch key {
		case "created_at":
			newTime, err := time.Parse(time.RFC3339, value.(string))
			if err != nil {
				e.CreatedAt = newTime
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "updated_at":
			newTime, err := time.Parse(time.RFC3339, value.(string))
			if err != nil {
				e.UpdatedAt = newTime
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "note":
			e.Note = value.(string)
		case "job_id":
			e.SetJobId(int64(value.(float64)))

			err := e.ConvertIdToJob(db)
			if err != nil {
				return errors.New("invalid associated job_id: " + strconv.FormatInt(e.JobId, 10))

			}
		}
	}
	return nil
}
