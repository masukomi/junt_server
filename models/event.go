package models

import (
	"errors"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"strconv"
	"time"
)

// ┌──────────────────────────────────────────┐
// │Event                                     │
// │-------------------------------------     │
// │id:          int                          │
// │job_id    :  int                          │
// │created_at:  date_time                    │
// │people_ids:  array of ints (optional)     │
// │note:        string (optional - markdown) │
// │                                          │
// │belongs_to:  job                          │
// │has_and_belongs_to_many: people           │
// └──────────────────────────────────────────┘

type Event struct {
	Id        int64     `json:"id" gorm:"PRIMARY_KEY";"AUTO_INCREMENT" ` // generated by DB
	CreatedAt time.Time `json:"created_at"`                              // generated if not supplied
	UpdatedAt time.Time `json:"updated_at"`                              // generated if not supplied

	Note      string `sql:"type:text;" json:"note"` // markdown
	JobId     int64  `json:"job_id"`
	Job       Job    `gorm:"foreignkey:JobId" json:"-"`
	EventType string `json:"event_type" gorm:"-"`
}

// implementing IEvent interface
func (e Event) CreationDate() time.Time {
	return e.CreatedAt
}

func (e Event) HolisticDeletion(db *gorm.DB) (bool, error) {

	transaction := db.Begin()
	if err := db.Delete(&e).Error; err != nil {
		transaction.Commit()
		return true, nil
	} else {
		transaction.Rollback()
		return false, err
	}

}

func (e *Event) UpdateEventFromJson(data map[string]interface{}, db *gorm.DB) error {

	for key, value := range data {
		switch key {
		case "created_at":
			newTime, err := time.Parse(time.RFC3339, value.(string))
			if err != nil {
				e.CreatedAt = newTime
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "updated_at":
			newTime, err := time.Parse(time.RFC3339, value.(string))
			if err != nil {
				e.UpdatedAt = newTime
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "note":
			e.Note = value.(string)
		case "job_id":
			e.JobId = int64(value.(float64))
			job := Job{}
			if db.First(&job, value).Error != nil {
				return errors.New("invalid associated job_id: " + strconv.FormatInt(e.JobId, 10))
				// why can I convert from an int with Itoa but not an int64?
			}
			e.Job = job
		}
	}
	return nil
}
