package models

import (
	"encoding/json"
	"errors"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"strconv"
	"time"
)

// ┌──────────────────────────────────────────────┐
// │Job                                           │
// │-----------------------------------------     │
// │id:                 int                       │
// │company_id:         int                       │
// │job_title:          string (optional)         │
// │posting_url:        string (url)              │
// │source:             string (optional)         │
// │referred_by:        string (optional)         │
// │salary_range:       string (optional)         │
// │application_method: string (optional)         │
// │note:               string (optional)         │
// │created_at:         date_time (optional)      │
// │updated_at:         date_time (optional)      │
// │start_date:         date_time (optional)      │
// │                                              │
// │                                              │
// │belongs_to:         company                   │
// │has_many:           events (maybe)            │
// │has_and_belongs_to_many:    people (hr contact(s))    │
// └──────────────────────────────────────────────┘
// dates are ISO 8601 RFC3339
// t, _ := time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")

type Job struct {
	// gorm.Model
	// Id, CreatedAt, UpdatedAt would normally come from gorm.Model but we need to specify
	// the json keys for them so...
	Id                int64     `json:"id" gorm:"PRIMARY_KEY";"AUTO_INCREMENT" `                // generated by DB
	CompanyId         int64     `json:"company_id"`                                             // belongs_to Company
	JobTitle          string    `gorm:"index:job_titles_idx" sql:"type:text;" json:"job_title"` // only required field
	PostingUrl        string    `sql:"type:text;" json:"posting_url"`
	Source            string    `sql:"type:text;" json:"source"`
	ReferredBy        string    `sql:"type:text;" json:"referred_by"`
	SalaryRange       string    `sql:"type:text;" json:"salary_range"`
	ApplicationMethod string    `sql:"type:text;" json:"application_method"`
	Note              string    `sql:"type:text;" json:"note"`           // markdown
	StartDate         time.Time `json:"start_date"`                      // generated if not supplied
	CreatedAt         time.Time `json:"created_at"`                      // generated if not supplied
	UpdatedAt         time.Time `json:"updated_at"`                      // generated if not supplied
	People            []Person  `gorm:"many2many:jobs_people;" json:"-"` // has and belongs to many people
	Company           Company   `gorm:"association_foreignkey:CompanyId" json:"-"`
	// `gorm:"foreignkey:UserMemberNumber;association_foreignkey:MemberNumber"`
}

func (j *Job) transactionableHolisticDeletion(db *gorm.DB, transaction *gorm.DB) (bool, error) {

	// find all the events
	// returns slice of IEvent objects
	iEvents, _ := GetIEvents(db, j.Id)
	// delete all the events
	for _, event := range iEvents {
		err := db.Delete(event).Error
		if err != nil {
			if transaction != nil {
				transaction.Rollback()
			}
			return false, err
		}
	}
	// delete the job
	if err := db.Delete(&j).Error; err == nil {
		if transaction != nil {
			transaction.Commit()
		}
		return true, nil
	} else {
		if transaction != nil {
			transaction.Rollback()
		}
		return false, err
	}
}

func (j *Job) HolisticDeletion(db *gorm.DB) (bool, error) {
	return j.transactionableHolisticDeletion(db, db.Begin())
}

func (j *Job) TransactionlessHolisticDeletion(db *gorm.DB) (bool, error) {
	return j.transactionableHolisticDeletion(db, nil)
}

func (j *Job) MarshalJSON() ([]byte, error) {
	people := j.People
	personIds := make([]int64, len(people))
	for idx, person := range people {
		personIds[idx] = person.Id
	}

	type Alias Job
	return json.Marshal(&struct {
		PersonIds []int64 `json:"person_ids"`
		*Alias
	}{
		PersonIds: personIds,
		Alias:     (*Alias)(j),
	})
}

func (j *Job) UpdateFromJson(data map[string]interface{}, db *gorm.DB) error {

	for key, value := range data {
		switch key {
		case "created_at":
			mTime := MaybeTimeFromValue(value.(string))
			if !mTime.IsError() {
				j.CreatedAt = mTime.Just
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "updated_at":
			mTime := MaybeTimeFromValue(value.(string))
			if !mTime.IsError() {
				j.UpdatedAt = mTime.Just
			} else {
				return errors.New("invalid updated_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "note":
			j.Note = value.(string)
		case "posting_url":
			j.PostingUrl = value.(string)
		case "source":
			j.Source = value.(string)
		case "referred_by":
			j.ReferredBy = value.(string)
		case "salary_range":
			j.SalaryRange = value.(string)
		case "application_method":
			j.ApplicationMethod = value.(string)
		case "job_title":
			if value == nil {
				return errors.New("Jobs must have a title")
			}
			j.JobTitle = value.(string)
		case "company_id":
			if value != nil {
				j.CompanyId = int64(value.(float64))
				maybeCompany := MaybeCompanyFromId(j.CompanyId, db)
				if !maybeCompany.IsError() {
					j.Company = maybeCompany.Just
				} else {
					return errors.New("invalid associated company_id: " + strconv.FormatInt(j.CompanyId, 10))
				}
			} else {
				return errors.New("company_id can't be nil")
			}
		}
	}
	return nil
}
