package models

import (
	"encoding/json"
	"errors"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"strconv"
	"time"
)

// ┌──────────────────────────────────────────┐
// │Person                                    │
// │----------------                          │
// │id:         int                           │
// │name:       string                        │
// │email:      string (optional)             │
// │phone:      string (optional)             │
// │created_at: date_time (optional)          │
// │updated_at: date_time (optional)          │
// │note:       string (optional - markdown)  │
// │                                          │
// │has_and_belongs_to_many:   events (maybe) │
// │has_and_belongs_to_many:   jobs (probably)│
// │                                          │
// │(events gets you interviews)              │
// └──────────────────────────────────────────┘
// dates are ISO 8601 RFC3339
// t, _ := time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")

type Person struct {
	// gorm.Model
	// Id, CreatedAt, UpdatedAt would normally come from gorm.Model but we need to specify
	// the json keys for them so...
	JobThing
	Id        int64     `json:"id" gorm:"PRIMARY_KEY";"AUTO_INCREMENT" `             // generated by DB
	Name      string    `gorm:"index:people_names_idx" sql:"type:text;" json:"name"` // only required field
	Email     string    `sql:"type:text;" json:"email"`
	Phone     string    `sql:"type:text;" json:"phone"`
	Note      string    `sql:"type:text;" json:"note"`           // markdown
	CompanyId int64     `json:"company_id"`                      // belongs_to Company
	CreatedAt time.Time `json:"created_at"`                      // generated if not supplied
	UpdatedAt time.Time `json:"updated_at"`                      // generated if not supplied
	Jobs      []Job     `json:"-" gorm:"many2many:jobs_people;"` // has and belongs to many jobs
	// overrides the one from JobThing
	Company      Company       `json:"-" gorm:"gorm:foreignkey:CompanyId"`
	ThanksEmails []ThanksEmail `json:"-" gorm:"many2many:people_thanks_emails;"` // has and belongs to many jobs
	Interviews   []Interview   `json:"-" gorm:"many2many:interviews_people;"`
	Followups    []Followup    `json:"-" gorm:"many2many:followups_people;"`
}

func (p Person) HolisticDeletion(db *gorm.DB) (bool, error) {

	transaction := db.Begin()
	if err := db.Delete(&p).Error; err != nil {
		transaction.Commit()
		return true, nil
	} else {
		transaction.Rollback()
		return false, err
	}

}
func (p *Person) MarshalJSON() ([]byte, error) {
	jobs := p.Jobs
	jobIds := make([]int64, len(jobs))
	for idx, job := range jobs {
		jobIds[idx] = job.Id
	}

	type Alias Person
	return json.Marshal(&struct {
		JobIds []int64 `json:"job_ids"`
		*Alias
	}{
		JobIds: jobIds,
		Alias:  (*Alias)(p),
	})
}

func (p *Person) UpdateFromJson(data map[string]interface{}, db *gorm.DB) error {

	for key, value := range data {
		switch key {
		case "created_at":
			mTime := MaybeTimeFromValue(value.(string))
			if !mTime.IsError() {
				p.CreatedAt = mTime.Just
			} else {
				return errors.New("invalid created_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "updated_at":
			mTime := MaybeTimeFromValue(value.(string))
			if !mTime.IsError() {
				p.UpdatedAt = mTime.Just
			} else {
				return errors.New("invalid updated_at time: \"" + value.(string) + "\" Use RFC3339")
			}
		case "note":
			p.Note = EmptyStringForNilString(value)
		case "name":
			p.Name = EmptyStringForNilString(value)
		case "email":
			p.Email = EmptyStringForNilString(value)
		case "phone":

			p.Phone = EmptyStringForNilString(value)
		case "company_id":
			if value != "" {
				p.CompanyId = int64(value.(float64))
				maybeCompany := MaybeCompanyFromId(p.CompanyId, db)
				if !maybeCompany.IsError() {
					p.Company = maybeCompany.Just
				} else {
					return errors.New("invalid associated company_id: " + strconv.FormatInt(p.CompanyId, 10))
				}
			} else {
				return errors.New("company_id can't be empty")
			}
		case "job_ids":
			if value != "" {
				jobIds := ExtractIdsFromJsonArray(value.([]interface{}))
				p.JobIds = jobIds
				p.ConvertIdsToJobs(db)
			}
		}
	}
	return nil
}
